"""Updates router — serves update manifests and download redirects.

The update manifest is stored as a JSON file on disk (or in a cloud bucket).
The build-update-package.ps1 script generates this file after each release.

## Deployment flow:
1. Run `npm run tauri build` → produces NSIS installer
2. Run `.\build-update-package.ps1` → produces manifest.json + offline package
3. Upload installer to CDN (DOWNLOAD_BASE_URL)
4. Place manifest.json where UPDATE_MANIFEST_PATH points (local file or fetch from bucket)
   OR use the admin API to publish releases.

## Environment variables:
- UPDATE_MANIFEST_PATH: Path to manifest.json on the server (default: ./update-manifest.json)
- RELEASES_DIR: Directory for release history (default: ./releases)
"""

from __future__ import annotations

import json
import logging
import os
from pathlib import Path
from typing import Any

from fastapi import APIRouter, Depends, HTTPException, Query, Response
from pydantic import BaseModel

from auth import get_current_user
from config import settings
from models import User

logger = logging.getLogger("licensing.updates")

router = APIRouter(tags=["updates"])

# Path to the current update manifest (generated by build-update-package.ps1)
_MANIFEST_PATH = os.environ.get("UPDATE_MANIFEST_PATH", "./update-manifest.json")
_RELEASES_DIR = Path(os.environ.get("RELEASES_DIR", "./releases"))

ADMIN_EMAILS: set[str] = set(
    e.strip() for e in settings.admin_emails.split(",") if e.strip()
)


def _require_admin(user: User) -> None:
    if user.email not in ADMIN_EMAILS:
        raise HTTPException(status_code=403, detail="Admin access required")


def _load_manifest() -> dict[str, Any] | None:
    """Load the current update manifest from disk."""
    p = Path(_MANIFEST_PATH)
    if not p.exists():
        return None
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        logger.exception("Failed to read update manifest from %s", p)
        return None


def _is_newer(local: str, remote: str) -> bool:
    """Compare semver-like versions. True if remote > local."""
    def parse(v: str) -> list[int]:
        return [int(x) for x in v.lstrip("v").split(".") if x.isdigit()]

    lv = parse(local)
    rv = parse(remote)
    for i in range(max(len(lv), len(rv))):
        l = lv[i] if i < len(lv) else 0
        r = rv[i] if i < len(rv) else 0
        if r > l:
            return True
        if r < l:
            return False
    return False


@router.get("/updates/check")
async def check_for_updates(
    version: str = Query(..., description="Current app version, e.g. '0.1.0'"),
    platform: str = Query("windows", description="Client platform, e.g. 'windows'"),
) -> Response:
    """Check whether a newer version is available.

    Returns:
    - 200 + UpdateManifest JSON if an update is available
    - 204 No Content if the client is already up to date
    - 503 if the manifest is not configured
    """
    manifest = _load_manifest()
    if manifest is None:
        raise HTTPException(
            status_code=503,
            detail="Update manifest not configured on the server.",
        )

    latest_version = manifest.get("version", "0.0.0")

    if _is_newer(version, latest_version):
        # Update available — return the full manifest
        return Response(
            content=json.dumps(manifest),
            media_type="application/json",
            status_code=200,
        )

    # Already up to date
    return Response(status_code=204)


# ── Admin release management ──────────────────────────────────────


def _ensure_releases_dir() -> None:
    _RELEASES_DIR.mkdir(parents=True, exist_ok=True)


def _load_all_releases() -> list[dict[str, Any]]:
    """Load all release manifests from the releases directory."""
    _ensure_releases_dir()
    releases = []
    for f in sorted(_RELEASES_DIR.glob("*.json"), reverse=True):
        try:
            data = json.loads(f.read_text(encoding="utf-8"))
            releases.append(data)
        except Exception:
            logger.warning("Skipping invalid release file: %s", f)
    return releases


def _release_path(version: str) -> Path:
    """Get path for a release file, sanitising version string."""
    safe = version.replace("/", "_").replace("\\", "_").replace("..", "_")
    return _RELEASES_DIR / f"{safe}.json"


class ReleaseManifest(BaseModel):
    version: str
    notes: str = ""
    pub_date: str = ""
    url: str
    sha256: str
    size: int = 0
    mandatory: bool = False


@router.get("/admin/releases/current")
async def get_current_release(
    user: User = Depends(get_current_user),
) -> Response:
    """Get the current (active) release manifest."""
    _require_admin(user)
    manifest = _load_manifest()
    if manifest is None:
        raise HTTPException(status_code=404, detail="No current release configured")
    return Response(
        content=json.dumps(manifest),
        media_type="application/json",
    )


@router.get("/admin/releases")
async def list_releases(
    user: User = Depends(get_current_user),
) -> list[dict[str, Any]]:
    """List all releases (newest first)."""
    _require_admin(user)
    return _load_all_releases()


@router.post("/admin/releases")
async def publish_release(
    body: ReleaseManifest,
    user: User = Depends(get_current_user),
) -> dict[str, Any]:
    """Publish a new release. Saves to release history and sets as current."""
    _require_admin(user)
    _ensure_releases_dir()

    manifest = body.model_dump()

    # Save to release history
    path = _release_path(body.version)
    path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")
    logger.info("Saved release %s to %s", body.version, path)

    # Set as current manifest (served to /updates/check)
    Path(_MANIFEST_PATH).write_text(
        json.dumps(manifest, indent=2), encoding="utf-8"
    )
    logger.info("Set release %s as current update manifest", body.version)

    return {"ok": True, "version": body.version}


@router.delete("/admin/releases/{version}")
async def remove_release(
    version: str,
    user: User = Depends(get_current_user),
) -> dict[str, Any]:
    """Delete a release from history. If it's the current release, clear it."""
    _require_admin(user)

    path = _release_path(version)
    if not path.exists():
        raise HTTPException(status_code=404, detail=f"Release {version} not found")

    path.unlink()
    logger.info("Deleted release %s", version)

    # If the current manifest is this version, remove it
    current = _load_manifest()
    if current and current.get("version") == version:
        try:
            Path(_MANIFEST_PATH).unlink()
            logger.info("Cleared current manifest (was %s)", version)
        except OSError:
            pass

    return {"ok": True, "deleted": version}

